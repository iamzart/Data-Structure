单链表

是线性表的一种
逻辑结构一定是线性的，物理结构不一定是线性的

链表由结点组成，结点由两部分组成
存在结构体里，一个数字，一个指针保存下一个结点的地址
指针指向的数据是什么类型，这个指针就是什么类型，现在这个只想下个结点，是结构体类型

定义链表结构--定义结点结构

**尾插
当链表为空，新结点就是首结点
不为空时，先找到最后一个节点tail，指向新结点的地址，就尾插了 
把向操作系统申请一个新结点，封装成函数

通过调试发现，形参phead发生了改变，但实参plist没有发生变化，所以在打印plist链表时，还是空链表

&只要看不到这个符号就是传值，不然根本没有取地址的操作
指针变量也是变量，是变量就要向操作系统要内存

pa保存了a的地址，a的地址就是pa的值！值！，但这个指针 指针变量也有地址呀
只是把0X100传给了形参，穿的是地址的值，地址类型的值
牛逼  
**pphead，解引用是那个地址，指向的元素的地址，不是它自己的地址

对一级指针plist解引用就是那个结点本身

如果要改变本身就要传址，但只有当链表本身为空的时候才会改变头节点，这里传二级指针，但else不改变头结点，一级二级无所谓

**头插
二级指针不能为空，否则不能解引用了
要断言

链表不需要增容，也没有空间浪费
头插尾插，顺序表和链表在不同场景下时间复杂度不同

  核心代码模式怎么调试就是vs，把代码拉过去，那里报错改哪里，手动创造一些数据

代码报错解决问题，才是向上走的暗示，提升的机会



















